---
layout: post
title: 数据结构 - 概述
categories: DataSturct
description: 数据结构的整体认知
keywords: DataSturct
---

Pascal 之父 尼古拉斯·沃斯 的著名言论: **算法 + 数据结构 = 程序** 道出了程序最初设计的本质,  
可见 **算法** 与 **数据结构** 对于计算机的重要性, 本系列主要记录通常意义上关于数据结构的基础知识

**目录**

* TOC
{:toc}

## 数据结构

### 是什么东西

计算机主要职责永远是用于计算, 其最初诞生的目的在于数值计算, 而今其计算内容涉及字符 表格 图像等等的数据格式

计算的对象是数据, 计算的方法则是算法, **狭义上的数据结构** 即算法所作用的对象的逻辑结构, 就是算法要算的东西,  **通常而言的数据结构** 指算法所作用的对象的逻辑结构及其所存储的结构

### 有什么用

复合的 特殊的数据无法直接用固定的方式描述出来, 学校学生的信息无法直接用数值描述, 领导与多个下属之间的关系无法用数值描述, 五大洲七大洋无法直接用数值描述, 需要为他们单独设计相应的数据模型, 才能够对他们进行分析和计算, 这就是数据结构研究的目的

### 是什么样子的

数据结构分为两大部分: **逻辑结构** 和 **存储结构**, 外表上看起来的样子就是他的逻辑结构, 它现实中的样子就是他的存储结构

数据结构相关的基本概念:  

概念 | 含义 | 举例
:-: | :-- | :--
数据 | 数据 | 文字 声音 色彩 图像等
对象 | 某一类事物的一个个体 | "手机" 这类事物中的 iphone4s, "人类" 中的马克思
数据元素 | 描述一个对象的所有数据, 即一个对象 | iphone4s 的所有信息, 如尺寸 薄厚 内存 存储 频率 价格... 也就是 iphone4s 本身
数据项 | 描述一个对象的某个数据 | iphone4s 的颜色
数据对象 | 性质相同的数据元素的集合 | "手机" 这一类事物, 或者是 "人类" 这一类事物, 可以看成是 类

#### 逻辑结构

可以看成是事物抽象出来的模型  

学校里有很多人, 每一个人都是一个对象, 即是一个**数据元素**, 这些人有校长 老师 主任 学生等等, 校长和老师 主任有层级**关系**, 学生与学生之间也存在着各种关系, 这一群人与这一群人之间的关系, 足以构建出学校中的这一类人的整体画像, 即可以构建出这一类人在我们思维中的逻辑模型

因此, 数据元素 + 关系 = 逻辑模型

##### 四种基本数据逻辑结构

* 集合结构: 数据彼此没啥关系, 一盘散沙
* 线性结构: 数据关系一对一, 一条线
* 树　结构: 数据关系一对多, 一棵树
* 图　结构: 数据关系多对多, 错综复杂, 像沙子彼此连起来了

集合结构:  

:satisfied:　　　:kissing:　　　:stuck_out_tongue_winking_eye:  
　　　　　:worried:　　　:frowning:  
　　:hushed:  
　　　　　:smirk:　:laughing:  

<br>
线性结构:  

:blush: :smiley: :relaxed: :sleeping: :stuck_out_tongue:

<br>
树　结构:  

├── :sleeping:  
├── :smirk:  
│   └── :angry:  
│       ├── :fearful:  
│       └── :open_mouth:  
├── :anguished:

<br>
图　结构:  

:blush: --- :smile:  
　|　　|  
:laughing: --- :smiley:

#### 存储结构

我们已经为数据构建出了概念模型, 我们知道 数据模型 = 数据元素 + 数据元素之间的关系, 因此, 我们在保存这一个数据模型的时候, 除了需要将所有数据元素的数据保存起来, 还需要保存众多数据元素之间关系  

因此在计算机中, 通常以**结点**的方式存储某一数据元素及其与其他数据元素之间的关系, 众多结点联合起来, 使得我们可以完整的构建出某一类数据完整的结构

结点是独立的, 一个一个的, 计算机存储信息时, 则需要一个一个的将结点存储进硬盘, 因此有两种存储方式:  
* 顺序存储: 结点一个接一个地连续存储在硬盘中
* 链式存储: 结点分散存储, 且结点里保存了其他结点的位置信息, 以指针的方式指向其他结点, 仿佛链子一般将结点连起来


*******

## 算法

算法是什么? 算法就是算法, 没什么好解释的

什么是算法? 这个需要清晰地认定:  
* 有穷性: 算的完
* 确定性: 算同样的东西, 结果永远一样
* 可行性: 可以实现
* 输　入: 有被算的东西(数据结构)
* 输　出: 要有结果

以上并没有要求算法是否绝对正确, 因此很多算法都是存在漏洞的, 即使一个算法是完全错误的, 它也是一个算法, 只是不是一个好算法而已, 那么该如何评价算法呢?

### 评价算法

* 正确性: 保证算出正确的结果是一个好算法的**前提**
* 鲁棒性: 也称健壮性, 保证算法在各种环境下都不会出错, 是一个好算法的**必要条件**
* 可读性: 容易让人理解的算法更有利于检错和修改
* 高效性: 合理高效的算法可以节省机器的运算资源和节省运算的时间, 以供更多运算  
    * 时间复杂度: 对运算时间的要求
    * 空间复杂度: 对运算内存的要求