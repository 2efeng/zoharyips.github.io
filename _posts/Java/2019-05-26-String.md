---
layout: post
title: Java - String 类
categories: Java
keywords: Java
modify: 2019-09-08 10:08
mathjax: true
---

Java 提供了默认的字符串类 (String), 本文主要记述了其基本用法和需要注意的细节, 本文忽略已过时或有关 Unicode 的方法


**目录**

* TOC
{:toc}

## “String对象”　与　“字符串”

1. String 对象并不等于字符串, 一个 String 实例化对象通过其私有成员 (`private final char value[]`) 来保存字符串内容, 由于使用习惯, 我们通常将 String 对象保存的字符串数组称为 **字符串的值**

    ```java
    // Source Code
    /** The value is used for character storage. */
    private final char value[];
    ```

2. 由于 String 对象使用 `private final char value[]` 数据成员来保存字符串内容，字符串以常量存储，String 对象与该字符串绑定在一起，因此 **String 是不可变的**；我们更改字符串的内容时，实际上是重新开辟了一个 String 实例空间，使用原来的变量名指向该新的实例空间。

    ```java
    // Test Code
    String string = "Hello World";
    String anotherName = string;
    string = "Hello man";
    System.out.println(anotherName == string);

    // Output:
    false
    ```

    anotherName 指向了原来 string 的地址，false 表示 string 所指向的地址发生了改变，即证明：String 是不可变的

3. 由于我们所理解的字符串实际上是 String 的一个对象, 因此当该对象名指向为空时, 调用其相关方法将发生空指针异常, 如: 
    ```java
    // Test Code
    String str = null;
    System.out.printf(str.hashCode()); // Exception!
    ```

## String的唯一性判断

* 使用 `==` 判断两个字符串对象的 **真实地址** 是否相等

* String 重写 `equals()` 方法: 逐个字符对比判断字符串对象的 **内容** 是否相等

* String 重写 `hashCode()` 方法: 相同内容的字符串算出来的结果是一样的，而非 String 对象的地址空间

    ```java
    // Source Code
    public int hashCode() {
        int h = hash;
        if (h == 0 && value.length > 0) {
            char val[] = value;

            for (int i = 0; i < value.length; i++) {
                h = 31 * h + val[i];
            }
            hash = h;
        }
        return h;
    }
    ```

因此，使用 `==` 可判断两个字符串对象是否为同一对象，使用 `equals()` 和 `hashCode()` 来判断字符串内容是否相等。

```java
// Test Code
String str1 = new String("Hello world");
String str2 = new String("Hello world");
System.out.println(str1 == str2);
System.out.println(str1.equals(str2));
System.out.println(str1.hashCode() == str2.hashCode());

// Output:
false
true
true
```


## 连接字符串

* 使用 `+` 连接二字符串

    使用此操作符进行字符串连接，无论连接的右操作数是否为空，都将返回一个新的字符串（即使该新字符串与原字符串一样）

* 使用 `concat()` 方法连接二字符串

    使用 `concat()` 方法进行字符串连接时，若传入的是 null，则将抛出空指针异常，因为内部调用了该参数的 length 方法；同时，若传入的是 `""`，则将返回原对象，这一点与 `+` 截然不同：

    ```java
    // Source Code
    public String concat(String str) {
        int otherLen = str.length();
        if (otherLen == 0) {
            return this;
        }
        int len = value.length;
        char buf[] = Arrays.copyOf(value, len + otherLen);
        str.getChars(buf, len);
        return new String(buf, true);
    }
    ```

如 [“String对象”　与　“字符串”](#“String对象”　与　“字符串”) 所说，字符串为常量，是不可变的，因此，若字符串发生更改，必将返回一个包含新值的新的字符串对象！

```java
// Test Code
String string = "Hello World";
String anotherName = string;
string.concat("");
System.out.println(anotherName == string);
string = string + "";
System.out.println(anotherName == string);

//Output:
true
false
```

## 字符串的长度


### 字符串的编码

```java
// Source Code
/**
 * ...The Java
 * platform uses the UTF-16 representation in {@code char} arrays and
 * in the {@code String} and {@code StringBuffer} classes...
 */
```

Java 使用的字符集是 Unicode，文档中声名默认使用 UTF-16 编码方式解析 Unicode，但由于 UTF-16 字符固定占 2 字节长度，对于英文字符（ASCII 字符占 1 字节）而言过于占用空间，因此 Java 会使用操作系统默认的编码方式对 Unicode 进行解析，使用非英文的系统大多使用 UTF-8 编码：

```java
// Test Code
System.out.println(Charset.defaultCharset());

// Output:
UTF-8
```

* Unicode 通称万国码，通过数字编码的方式来存储字符，理论长度从 000000 到 10FFFF 共 4180000 （2^20 + 2^16）个编码； 

* UTF（Unicode Transformation Format）是 Unicode 从数字转化为字符的方案，而 UTF-8 是其中一套可变长度的转化方案，UTF-16 是双字节定长的转化方案；这就表明了，对于英文字符，UTF-8 将仅占用单字节长度来表示，大大节省了空间。

* UTF-8 转换规则

    * 如果只有一个字节则其最高二进制位为0；

    * 如果是多字节，其第一个字节从最高位开始，连续的二进制位值为1的个数决定了其编码的字节数，其余各字节均以10开头。

    * UTF-8 转换表

        Unicode | bit | Unit | UTF-8 | byte 
        :-: | :-: | :-: | :-: | :-:
        0000 ~ 007F | 00~07 | 1 | 0XXX XXXX | 1
        0080 ~ 07FF | 08~11 | 1 | 110X XXXX<br/>10XX XXXX | 2
        0800 ~ FFFF | 12~16 | 1 | 110X XXXX<br/>10XX XXXX<br/>10XX XXXX | 3
        01 0000 ~ 10 FFFF | 17~21 | 2~n | 110X XXXX<br/>10XX XXXX<br/>10XX XXXX<br/>10XX XXXX | 4

### 字符长度与字符串长度

如果系统采用的编码方式是 UTF-8，那么恭喜你，你的字符串的长度会变来变去；这是由于 UTF-8 是可变长的编码方式所决定的：

```java
// Test Code
String string;
string = "ab";
getStringInfo(string);
string = "你好";
getStringInfo(string);
string = "𡃁𡃁";
getStringInfo(string);
string = "👦👩";
getStringInfo(string);
string = "👽👽‍";
getStringInfo(string);

...
private static void getStringInfo(String string) {
    System.out.println(string + ".length\t\t\t\t= " + string.length());
    System.out.println(string + ".toCharArray.length\t= " + string.toCharArray().length);
    System.out.println(string + ".getBytes.length\t= " + string.getBytes().length);
}

// Output:
ab.length = 2
ab.toCharArray.length = 2
ab.getBytes.length = 2
你好.length = 2
你好.toCharArray.length = 2
你好.getBytes.lengt = 6
𡃁𡃁.length = 4
𡃁𡃁.toCharArray.length = 4
𡃁𡃁.getBytes.length = 8
👦👩.length = 4
👦👩.toCharArray.length = 4
👦👩.getBytes.length = 8
👽👽.length = 5
👽👽.toCharArray.length = 5
👽👽.getBytes.length = 11
```

* `String.length()` 方法返回的是 Unicode 单元的长度

* `String.toCharArray.length()` String 本来就是 Char 数组，同样是 Unicode 单元的长度

* `String.getBytes.length()` 方法将返回 UTF-8 编码的字节数组长度

目前的 Unicode 字符分为17组编排，0x0000 至 0x10FFFF，每组称为平面（Plane），而每平面拥有FFFF(65536) 个码位。我们平时使用的字符基本上都在 BMP(Basic Multilingual Plane，基本多语言平面) 中，即 Plane 0，范围为：0000 ~ FFFF 共 65536 个字符，占 1 个 Unicode 单元，从转换表中可以看出，其 UTF-8 编码占 1~3 个 bit 长度。

因此，上例子中的 `𡃁𡃁`、`👦👩`、`👽👽‍` 由于是 Unicode 3.0 后加入的字符，早已超出 BMP 所能表示的字符，因此需要占用 2 个及以上的 Unicode 单元，因此所求得的字符串长度会和显示的字符长度不一致，这是一个坑！

而由于 UTF-8 是变长编码，Byte 数组长度不一则是很正常的表现了。

而如果需要获取与实际相比较精准的字符数量，则需要使用 `String.codePotinCount` 方法：

```java
// Test Code
string = "ab";
System.out.println(string.codePointCount(0, string.length()));
string = "你好";
System.out.println(string.codePointCount(0, string.length()));
string = "𡃁𡃁";
System.out.println(string.codePointCount(0, string.length()));
string = "👦👩";
System.out.println(string.codePointCount(0, string.length()));
string = "👽👽‍";
System.out.println(string.codePointCount(0, string.length()));

// Output:
2
2
2
2
3
```

至于... 最后一个是怎么回事，我至今没搞懂...

![奇怪的emoji](/images/posts/string/1.png)

竟然是五？？？

## hashCode() 的魔法值

在上文 [String的唯一性判断](#String的唯一性判断) 中，我们通过 hashCode() 方法判断字符串内容是否相同，但在哈希函数中，有一个很奇怪的乘子：31

```java
/** The value is used for character storage. */
private final char value[];

/** Cache the hash code for the string */
private int hash; // Default to 0

/**
 * Returns a hash code for this string. The hash code for a
 * {@code String} object is computed as
 * <blockquote><pre>
 * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]
 * </pre></blockquote>
 * using {@code int} arithmetic, where {@code s[i]} is the
 * <i>i</i>th character of the string, {@code n} is the length of
 * the string, and {@code ^} indicates exponentiation.
 * (The hash value of the empty string is zero.)
 *
 * @return  a hash code value for this object.
 */
public int hashCode() {
    int h = hash;
    if (h == 0 && value.length > 0) {
        char val[] = value;

        for (int i = 0; i < value.length; i++) {
            h = 31 * h + val[i];
        }
        hash = h;
    }
    return h;
}
```

文档中给出了这个哈希函数的算法，通过推导检验算法：

```java
// s = val; n = length
s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]

// Check
length=1 -> h = 31 * 0 + val[0]
              = val[0]

length=2 -> h = 31 * (31 * 0 + val[0]) + val[1]
              = 31 * val[0] + val[1]
              = val[0] * 31^(2-1) + val[1]

length=3 -> h = 31 * (31 * (31 * 0 + val[0]) + val[1]) + val[2]
              = 31 * 31 * val[0] + 31 * val[1] + val[2]
              = val[0] * 31^(3-1) + val[1] * 31^(3-2) + val[2]

length=n -> h = val[0] * 31^(n-1) + val[1] * 31^(n-2) + ... + val[n-1]
```

将哈希算法写成数学公式为：

$$hash = \sum_{i=0}^{n-1}value[i]\ *\ 31^{n-1-i}$$

而由于整型的数值边界是 $$ 2^{31} $$ ，所以实际上是：

$$hash = \sum_{i=0}^{n-1}value[i]31^{n-1-i} \quad Mod \quad 2^{31} $$


31 有以下几个性质：

* 31 是一个质数

* 31 = $$ 2^{5} - 1$$

由于 31 所具备的性质，以下解释乘子采用 31 的原因：

1. 哈希算法所采用的模或者是乘子采用质数能够有效地减小碰撞，参考 [哈希表的大小为什么最好是素数](https://blog.csdn.net/maoliran/article/details/52082829)

2. 由于它的第二个性质，JVM 自动对它进行了优化：

    ```java
    // 31 = 2^5 - 1
    31 * i == i * (2^5 - 1) == i << 5 - i
    ```

    移位运算大大提高了循环运算的效率

3. value[n] 是字符串中字符所在的 Unicode 平面的编号，范围从 0 到 65536；太小的质数进行哈希运算碰撞率会提高，而太大的质数进行哈希运算导致运算成本陡增，因此必须选用适中的质数，而由于 31 存在优化且碰撞率并不算高，因此选用 31 作为乘子

    ![奇怪的emoji2](/images/posts/string/2.png)

参考：

* [哈希表的大小为什么最好是素数](https://blog.csdn.net/maoliran/article/details/52082829)
* [科普：为什么String hashCode 函数使用 31 作为乘子](https://segmentfault.com/a/1190000010799123)
* [一个Java字符串中到底有多少个字符?](https://colobu.com/2019/01/04/how-many-charactors-in-a-java-string/)
